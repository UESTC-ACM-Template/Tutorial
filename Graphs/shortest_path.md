## 最短路

定义（$s-t$路）：给定一张图$G=(V,E)$和$s,t$两点，一条$s-t$路$P$是一个点和边交错形成的序列
$$
P=\{s,(s,v_1),v_1,(v_1,v_2),\cdots,(v_{k-1},v_k),v_k,(v_k,t),t\}
$$
若给定权函数$w$，则称该路径上所有边权之和为该路径的权值/长度。若路径经过的点不重复，则称其为简单路径。

定义（圈）：若一条$s-t$路的起点和终点相同，则称其为圈。若其经过的点不相同，则称其为简单圈。圈的权即该圈上所有边权之和。

定义（单源最短路径）：给定一张图$G=(V,E)$和权函数$w:E \to \R$和源点$s$，对于其他每个点$t\in V$找出最短的$s-t$路。

命题：当图中存在长度为负数的圈且存在一条$s-t$路经过该圈上的点，则不存在最短的$s-t$路。

证明：略。

命题：

命题：若存在最短$s-t$路，则存在一条最短$s-t$简单路。

证明：若某条最短$s-t$路经过了重复的点，则其在第一次和第二次碰到该点之间走过了一个圈。因为最短$s-t$路存在所以图中不存在负权圈，所以将该圈删去不会增加权值。因此要么这条路径不是最短路导出矛盾，要么可以一直迭代下去将所有圈全部删掉得到一条简单路径。

### 单源最短路径算法

以下如无特别声明则默认存在最短$s-t$路。

最短路问题有一个良好的性质。

命题：对于任意一条最短$s-t$路$P$其中任意一个点$u$，则$P$中的$s-u$部分和$u-t$部分分别是最短$s-u$路和最短$u-t$路。

利用这个性质可以设计出基于动态规划/贪心的最短路算法。

#### Bellman-Ford

其核心思路为任意一条由$k$条边组成的最短路都能通过一条由$k-1$条边组成的最短路加上一条边构成。

算法（Bellman-Ford）：

定义DP状态`dp[i][u]`表示由$i$条边组成的最短$s-u$路长度。

边界为`dp[0][s]=0,dp[0][v]=inf`，其中`v!=s`。

对于$i$从$0$到$n-2$，对于$u\in V$，枚举$u$的出边$(u,v)$并将其接在已经求出的由$i$条边组成的最短$s-u$路后面，即可从`dp[i][u]`转移至`dp[i+1][v]`。

最终的`dp[n-1][t]`即是最短$s-t$路长度。在转移过程中维护一个`pre`数组即可从`t`开始回溯至`s`来将具体方案构造出来（若发生转移则将`pre[v]`设成`u`）。

因为每一轮只有发生转移的`v`才会对下一轮产生影响，所以可以利用一个先入先出的队列来维护每一轮发生转移的顶点集合。（可以用一个额外数组记录每个点是否已经在队列内）

由此获得的算法被称为SPFA。这两个算法的最坏时间复杂度均为$O(nm)$。（队列优化并没有改变最坏复杂度，但是在随机图上跑的飞快。）

若图中可能存在负圈，则可在$n-1$轮迭代的基础上继续迭代，若仍然发生了状态更新，则说明存在负圈。

这在SPFA中体现为节点入队次数超过$n-1$次。

#### Dijkstra

对于无负权边的图，存在另一个基于贪心的最短路算法。

其核心思路为依次求出从$s$到其他点的最短路，并维护从$s$出发只经过已被求出最短路的点到其他所有点的最短路径长度上界。

算法（Dijkstra）：

维护一个点集$S$和到所有点的已知最短距离$d$。

其中$d(u)$为除$u$外不经过任何$S$以外的点的最短$s-u$路长度。

最初$S=\{s\}$。

每一轮迭代中选出属于$V-S$的$d(u)$最小的$u$将其放入$S$，并用其所有出边$(u,v)$更新$d(v):=\min\{d(v),d(u)+w(u,v)\}$。

正确性证明：

即证每一轮迭代中将$u$拿出时已经求出最短$s-u$路。

对迭代轮数进行归纳。即证若将$u$放入$S$时到$s$到$S$中所有点的最短路已被求出，则任意一条$s-u$路长度不小于$d(u)$。

考虑任意一条$s-u$路$P$，若其经过了不属于$S$的点$v$，则最短$s-v$路长度$d(v)$大于等于$d(u)$，且最短$v-u$路长度非负，因此其长度大于等于$d(u)$。得证。

复杂度分析与实现:

该过程本质是维护一个集合，支持取出权值最小元素和修改权值。

取出最小元素的次数为$n$次，修改权值的次数为$m$次。

用$F$堆实现即可获得非常漂亮的$O(m+n\log n)$，但常数巨大。

一般图方便会使用`std::priority_queue`或使用`__gnu_pbds`中的配对堆。此时复杂度为$O((n+m)\log m)$或$O((n+m)\log n)$。

前者无法直接修改内部权值，一般的做法是丢进去一个`std::pair`，`first`为长度，`second`为顶点编号。需要修改权值时直接将新权值构成的`pair`丢进去。新权值一定会比老权值先出堆，碰到老权值时丢弃即可。

注：`std::priority_queue`的比较谓词默认为`std::less`，这会使其成为大顶堆！将其改成`std::greater`即可获得适用Dijkstra算法的小顶堆。

#### 势函数

负权边会让Dijkstra失去正确性，这让人很难受。毕竟$|V|$大的时候$O(|V||E|)$是一个无法忍受的复杂度。

若存在一个神奇的势函数$\pi:V \to \R$使得$\forall (u,v) \in E$有$\pi(u)-\pi(v)+w(u,v) \geq 0$，则Dijkstra也能适用于含负权边的图。令新权函数$w'(u,v)=w(u,v)+\pi(u)-\pi(v)$，则新图中任意一条$s-t$路的权值都等于原图中$s-t$路的权值加上$\pi(s)-\pi(t)$。因此新图中的最短路与原图中的最短路相同。

定理：

### 多源最短路径算法

命题：单源最短路径算法结束后的距离标记$d$满足$\forall (u,v) \in E,d(v)-d(u) \leq w(u,v)$。

证明：若不满足则可用$(u,v)$这条边来更新$d(v)$获得更短的路径，这与最短路算法结果矛盾。

将$d(v)-d(u)$挪到右边即可得到$d(u)-d(v)-w(u,v)\geq 0$。因此任意一次最短路算法的结果都是一个有效的势函数。

#### Johnson

定义（多源最短路径）：对于一个点集$S$中的每一个点求出从其出发的单源最短路径。

Johnson算法的核心思路是将负权边通过势函数变成非负权边。

算法(Johnson)：

若图中不存在负权边则从每个点出发跑Dijkstra，否则进行以下过程：

新建一个点$x$，对于$V$中的每个点$v$新建一条边$(x,v)$，权值为$0$。

使用Bellman-Ford求解从$x$出发的单源最短路径，获得距离标记$d$。

将$d$作为势函数得到一个权非负的新图，从每个点出发跑Dijkstra。

不难证明复杂度是$O(nm+n^2\log n)$。

#### Floyd-Warshall





### 最短路与线性规划

前置：线性规划及其对偶

定理（最短路的费用流表示）：最短路可表示成流量为$1$的最小费用流问题。即

$$
\max -k_{uv}x_{uv}\\
s.t. \\
\forall v \in V, \sum_{(u,v) \in E}x_{uv}-\sum_{(v,u) \in E}x_{vu}=
\begin{cases}
-1&v=s\\
1&v=t\\
0&else
\end{cases}\\
\forall (u,v) \in E,x_{uv}+y_{uv}=1\\
x_{uv},y_{uv}\geq0
$$
考虑建立其对偶问题。

对于点$u$的流量平衡，其对偶变量为$w_u$。

对于边$(u,v)$的流量限制，其对偶变量为$z_{uv}$。

对于边$(u,v)$上的流量$x_{uv}$，其在点$u$的流量平衡中系数为$-1$，在点$v$的流量平衡中系数为$1$，在边$(u,v)$的流量限制中系数为$1$，其价值系数为$-k_{uv}$

对于边$(u,v)$上流量限制的松弛变量$y_{uv}$，其在边$(u,v)$的流量平衡中系数为$1$。

于是其对偶问题为
$$
\max -(w_t-w_{s})\\
s.t.\\
\forall (u,v)\in E,w_v-w_u+z_{uv}\geq-k_{uv}\\
\forall (u,v)\in E,z_{uv}\geq 0
$$
令$z_{uv}=0$，$d_u=-w_u$即得

定理（最短路的差分约束表示）：
$$
\max d_t-d_s\\
s.t.\\
\forall (u,v) \in E, d_v-d_u \leq k_{uv}
$$
不难看出$d_u-d_s$即为点$s$到点$u$的最短路距离。

----

