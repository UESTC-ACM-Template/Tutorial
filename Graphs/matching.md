# 匹配

********

定义：

匹配：一张图$G=(V,E)$里的一个匹配$M$是边集$E$的一个不包含自环的子集，且其中任意两条边不共端点。若顶点$u$是$M$中的某一条边的一个端点，则称顶点$u$在匹配中。

极大匹配：对于一张图$G=(V,E)$上的一个匹配$M$，若对于$E$中的任意一条边$(u,v)$，$M \cup \{(u,v)\}$不是匹配，则$M$是$G$上的一个极大匹配。

最大匹配：对于一张图$G=(V,E)$上的一个匹配$M$，若对于$G$上的任意一个匹配$M'$都有$|M| \geq |M'|$，则$M$是$G$上的一个最大匹配。

完美匹配：对于一张图$G=(V,E)$上的一个匹配$M$，若$V$中的任意一个顶点都在$M$中，则$M$是$G$的一个完美匹配。

带权匹配：对于一张带权$w:E\rightarrow\R$的图$G=(V,E)$上的一个匹配$M$，$M$的权值为其包含的所有边权之和。即$w(M)=\sum_{e\in E}w(e)$。

最大权匹配：对于一张带权$w:E\rightarrow\R$的图$G=(V,E)$上的一个匹配$M$，若对于$G$上的任意一个匹配$M'$都有$w(M) \geq w(M')$，则$M$是$G$上的一个最大权匹配。

最大权完美匹配：对于一张带权$w:E\rightarrow\R$的图$G=(V,E)$上的一个完美匹配$M$，若对于$G$上的任意一个完美匹配$M'$都有$w(M) \geq w(M')$，则$M$是$G$上的一个最大权完美匹配。

********

二分图上的匹配问题显然可以归约到网络流问题上，但存在针对这些专门设计的算法（往往是前者的特例），实现难度与常数均较小。

一般图上的匹配问题则较难归约到网络流问题上，且难度较二分图上的匹配问题显著增大。

**常见的匹配算法一般使用增广路寻找最大（权）匹配。**

********

定义：

交错路：对于一张图$G=(V,E)$与其上的一个匹配$M$，$G$上的一条简单路径$P=\{u_1, u_2,...,u_k\}$被成为交错路当且仅当$P$中任意两条相邻边$e_1, e_2$均满足其中一条是匹配边而另一条不是。

增广路：对于一张图$G=(V,E)$与其上的一个匹配$M$，**$G$上的一条交错路$P=\{u_1, u_2,...,u_k\}$是增广路当且仅当其起点$u_1$与终点$u_k$均不在匹配中。**$P$这样的路径被称为增广路是因为在$M$的基础上，若**将增广路$P$中的匹配边移除并将非匹配边加入，可以得到一个新的匹配$M'$且$|M'|=|M|+1$**。（证：因为其起点与终点都不在匹配中，且反转匹配状态后链上每个点仍然仅在一条匹配边中，所以更改匹配状态后不存在两条共顶点的匹配边。）

********

定理（增广路）：
**对于一张图$G=(V,E)$与其上的一个匹配$M$，$M$是$G$的最大匹配当且仅当$G$中不存在增广路。**

证明：

充分性：已知$G$中不存在增广路，接下来需要证明$M$是最大匹配。设$G$的一个最大匹配为$M'$，考虑边集$E'=M \bigoplus M'$（$\bigoplus$为对称差）。

性质1：$E'$中的任意一个顶点度数不超过2。因为任意一个顶点只能被至多两条边作为端点，一条属于$M$而一条属于$M'$。那么$E'$中的任意一个联通分量只能是链或者环。

性质2：$E'$中的任意一个连通分量都不是长度为奇数的链。
若是则其必定是$M'$或$M$的增广路，则要么$M'$不是最大匹配，要么对于$M$存在增广路，产生矛盾。所以$E'$中的任意一条链连通分量都包含相等数量的$M$与$M'$中的边。

性质3：$E'$中的任意一个连通分量都不是长度为奇数的环。
若是则环上必定有两条相邻边属于同一个匹配，产生矛盾。所以$E'$中的任意一个环连通分量都包含相等数量的$M$与$M'$中的边。

所以$E'$中包含相等数量的$M$与$M'$中的边，所以$|M|=|M'|$，$M$是一个最大匹配。

必要性：已知$M$是最大匹配。若$G$中存在增广路则可将其匹配状态翻转使$M$增大，导出矛盾。所以$G$中不存在增广路。

绝大部分匹配算法的核心思路都是寻找增广路。

## 二分图最大匹配

定义：给定一个二分图$G=(X \cup Y,E)$，求$G$中的一个最大匹配。

### 匈牙利算法(最大匹配)

原理：即增广路定理。

过程：依次从每个点出发用dfs寻找增广路。

正确性证明：

需要证明算法结束时图中不存在增广路，即若遍历到某个X中顶点$u$出发未能找到增广路，则此后一直不存在从$u$出发的增广路。

********

引理1：在算法运行中，若从点$u$出发无法找到增广路，之后任意阶段$u$通过交错路能到达的任意Y节点的匹配节点与之前相同。

引理1证明：

若从X节点$u$出发无法找到增广路，则从$u$出发寻找增广路时，$u$通过交错路能够到达的所有Y节点均已被匹配。不妨设找到了从X节点$u'$到Y节点$v'$的增广路$P'$并将其反转后$u$通过交错路$P$到达的Y节点$v$的匹配点从X节点$w_1$变成了X节点$w_2$。即：

$$P=u \dashrightarrow \cdots \dashrightarrow v$$

$$P'=u' \dashrightarrow \cdots \rightarrow w_1 \dashrightarrow v \rightarrow w_2 \dashrightarrow \cdots  \dashrightarrow v'$$

于是
$$u \dashrightarrow \cdots \dashrightarrow v \rightarrow w_2 \dashrightarrow \cdots  \dashrightarrow v'$$
是一条增广路，与假设矛盾。

推论1：在算法运行中，若从点$u$出发无法找到增广路，之后任意阶段$u$通过交错路能到达的Y节点与之前相同。

$u$通过交错路能到达的Y节点的匹配节点不会发生改变，所以从$u$出发的交错路不会发生改变。

********

因为在算法运行过程中，已匹配点不会变为未匹配点，所以若从$u$出发无法找到增广路，则之后永远不存在从$u$出发的增广路，因为$u$通过交错路能够到达的Y节点不会发生改变。

因此若从点$u$出发无法找到增广路，则之后因为从$u$出发能够达到的Y节点不会发生改变，所以之后也不可能找到增广路。进而算法结束后不存在从任意一个未匹配点出发的增广路，算法找到的匹配是最大匹配。

********

实现：

```cpp
const int N = 100001;
typedef pair<int, int> pii;

namespace matching {

vector<int> g[N];   //  g[u]:X中顶点$u$的邻接表
bool vis[N];        //  vis[u]:当前dfs中Y中顶点u是否已被访问过
int lnk[N];         //  lnk[u]:Y中顶点u对应的匹配点。若u未被匹配则lnk[u]=0

//  从X顶点u出发寻找增广路
bool dfs(int u) {
    for (int v : g[u]) {
        //  v已被访问过，且无法从v出发找到增广路或增广路的上一个节点是v则跳过
        if (vis[v] || lnk[v] == u) continue;
        //  v未被访问过，标记v
        vis[v] = 1;
        //  v已有匹配点，且无法从v出发找到增广路则跳过
        if (lnk[v] && !dfs(lnk[v])) continue;
        //  v没有匹配点或找到从lnk[v]出发的增广路，则设v的匹配点为u
        lnk[v] = u; return true;
    }
    //  找不到增广路
    return false;
}

//  接口:
//  int nl: X节点数; X中节点编号为[1...nl]
//  int nr: Y节点数; Y中节点编号为[1...nr]
//  const vector<pii>& es: 二分图中的边集。pii的first为X中节点编号，second为Y中节点编号
//  返回值vector<pii> res: 得到的最大匹配。
vector<pii> match(int nl, int nr, const vector<pii>& es) {
    //  初始化，建图
    for (int i = 1; i <= nl; ++i)
        g[i].clear();
    fill_n(lnk + 1, nr, 0);
    for (pii e : es)
        g[e.first].push_back(e.second);
    //  依次从每个点出发寻找增广路
    for (int i = 1; i <= nl; ++i) {
        fill_n(vis + 1, nr, false);
        dfs(i);
    }
    //  按Y中每个点i的匹配点lnk[i]得到结果
    vector<pii> res;
    for (int i = 1; i <= nr; ++i)
        if (lnk[i]) res.emplace_back(lnk[i], i);
    return res;
}

}
```

********

复杂度：

定理：匈牙利算法的时间复杂度为$O(VE)$，空间复杂度为$O(V+E)$。

共进行$V$轮时间复杂度为$O(E)$的DFS寻找增广路，因此时间复杂度为$O(VE)$。

### Hopcroft-Karp

原理：每次在分层图上寻找多条增广路。

## 二分图最大权匹配（施工中）

### 匈牙利算法（最大权完美匹配）

注：也叫Kuhn-Munkres算法（这两个人是匈牙利人）

原理：相等子图中的完美匹配是原图中的最大权完美匹配

KM为每个顶点定义了一个被称为顶标的值，在算法运行的每个阶段保持对于任意一条边$(u,v)$有$A(u)+B(v)\geq w(u,v)$。同时称由满足$A(u)+B(v)=w(u,v)$的所有边组成的子图为相等子图。

注2：如非特别注明，本段中$u \in X, v \in Y, w(u,v)$为边$(u,v)$的权，$X$中点$u$的顶标被记为$A(u)$，$Y$中点$v$的顶标被记为$B(v)$。

原理证明：

若相等子图中存在完美匹配$M$，显然$w(M)=\sum_{u \in X}A(u)+\sum_{v \in Y}B(v)$。注意到对于图中的任意一个完美匹配$M'$有$w(M')=\sum_{(u,v)\in M'}w(u,v)\leq\sum_{(u,v)\in M'}A(u)+B(v)=w(M)$，所以$M$是最大权完美匹配。

过程：

与寻找二分图最大匹配的过程类似，依次从每个点出发**在相等子图中**寻找增广路。若无法找到则通过调整顶标使相等子图扩大。

在无法找到增广路的情况下，从每个点出发的交错路形成了一棵交错树，其所有叶子都是X顶点。不妨设交错树中的X顶点集合为$S$，而Y顶点集合为$T$。考虑如何调整顶标才能在满足约束$\forall(u,v) \in E,A(u)+B(v) \geq w(u,v)$的情况下使得：

1. 原来在交错树中的边之后依然在交错树中。
2. 原来X顶点在交错树，而Y顶点不在交错树中的边被加入相等子图。

由约束1，对于交错树中的每条边，其X顶点的顶标的调整值与Y顶点的顶标的调整值必须互为相反数。即对于交错树中的所有X顶点，其顶标必须被加上一个数，而Y顶点的顶标需要被减去一个数，不妨设其为$d$。

考虑到这样的调整对原来X顶点在交错树中而Y顶点不在交错树中的边的影响，为满足这些边对顶标带来的约束，必有

$$d = \min_{u \in S, v \notin T}A(u)+B(v)-w(u,v)$$

考虑这种调整对图中所有边造成的影响：

1. $u \in S, v \in T$，$A(u)-d+B(v)+d=A(u)+B(v)\geq w(u,v)$，没有影响。
2. $u \notin S, v \notin T$，没有影响。
3. $u \in S, v \notin T$，$A(u)-d+B(v)\geq w(u,v)$，一些这类边被加入了相等子图中
4. $u \notin S, v \in T$，$A(u)+B(v)+d > w(u,v)$，没有影响。

由二分图最大匹配的经验我们很容易写出暴力寻找调整值$d$的算法。其复杂度如下：

1. 从每个顶点出发尝试寻找增广路，至多寻找$O(n)$次。
2. 每次寻找增广路，至多遍历$O(n^2)$条边。
3. 寻找失败则调整顶标，每次调整会使得至少一个Y顶点被加入交错树，所以至多调整$O(n)$次。
4. 通过遍历边集来计算调整值，至多遍历$O(n^2)$条边。

因此这种暴力的时间复杂度是$O(n^4)$。

考虑如何优化寻找增广路与计算顶标调整值的过程。因为交错树一直在扩大，所以每次我们不需要重新DFS尝试增广，而是以类似BFS的形式从交错树的叶子开始增广，并在这一过程中同时计算调整值。

不难设计出如下过程：

1. 从每个顶点出发尝试寻找增广路，至多寻找$O(n)$次。
2. 对当前顶点$u$，设$u$的匹配点为$0$。设$v=0$并重复如下过程。
3. 设$v$已被访问。
4. 对$v$的匹配点的邻接表中的边$(u',v')$。
5. 若$v'$已被访问则回到3。
6. 若$(u',v')$不在相等子图中则令$d=\min(d,A(u')+B(v')-w(u',v'))$，并设$pre(v')=v$。
7. 若$(u',v')$

```cpp
namespace matching {

vector<int> g[N];
int lnk[N], pre[N];
bool vis[N];

ll a[N], b[N], w[N][N], sl[N];

vector<pair<pii, ll>> match(int nl, int nr, const vector<pair<pii, ll>>& es) {
    nr = max(nl, nr);
    fill_n(lnk + 1, nr, 0);
    for (int i = 1; i <= nl; ++i)
        fill_n(w[i] + 1, nr, 0);
    for (pair<pii, ll> e : es)
        w[e.first.first][e.first.second] = max(w[e.first.first][e.first.second], e.second);
    for (int i = 1; i <= nl; ++i)
        a[i] = *max_element(w[i] + 1, w[i] + nr + 1);
    fill_n(b + 1, nr, 0);
    for (int i = 1, j, u, vt = 0; i <= nl; ++i) {
        fill_n(vis + 1, nr, 0);
        fill_n(sl + 1, nr, inf);
        fill_n(pre + 1, nr, 0);
        lnk[0] = i;
        for (j = 0; u = lnk[j]; j = vt) {
            ll d = inf; vis[j] = 1;
            for (int v = 1; v <= nr; ++v) {
                ll t = a[u] + b[v] - w[u][v];
                if (vis[v]) continue;
                if (sl[v] > t) sl[v] = t, pre[v] = j;
                if (sl[v] < d) d = sl[v], vt = v;
            }
            for (int v = 0; v <= nr; ++v) {
                if (vis[v]) a[lnk[v]] -= d, b[v] += d;
                else sl[v] -= d;
            }
        }
        for (; j; j = pre[j]) lnk[j] = lnk[pre[j]];
    }
    vector<pair<pii, ll>> res;
    for (int i = 1; i <= nr; ++i)
        res.emplace_back(pii(lnk[i], i), a[lnk[i]] + b[i]);
    return res;
}

}
```

## 二分图上的特殊顶点集与匹配

### 最大独立集


