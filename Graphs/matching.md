# 匹配

********

定义：

匹配：一张图$G=(V,E)$里的一个匹配$M$是边集$E$的一个不包含自环的子集，且其中任意两条边不共端点。若顶点$u$是$M$中的某一条边的一个端点，则称顶点$u$在匹配中。

极大匹配：对于一张图$G=(V,E)$上的一个匹配$M$，若对于$E$中的任意一条边$(u,v)$，$M \cup \{(u,v)\}$不是匹配，则$M$是$G$上的一个极大匹配。

最大匹配：对于一张图$G=(V,E)$上的一个匹配$M$，若对于$G$上的任意一个匹配$M'$都有$|M| \geq |M'|$，则$M$是$G$上的一个最大匹配。

完美匹配：对于一张图$G=(V,E)$上的一个匹配$M$，若$V$中的任意一个顶点都在$M$中，则$M$是$G$的一个完美匹配。

带权匹配：对于一张带权$w:E\rightarrow\R$的图$G=(V,E)$上的一个匹配$M$，$M$的权值为其包含的所有边权之和。即$w(M)=\sum_{e\in E}w(e)$。

最大权匹配：对于一张带权$w:E\rightarrow\R$的图$G=(V,E)$上的一个匹配$M$，若对于$G$上的任意一个匹配$M'$都有$w(M) \geq w(M')$，则$M$是$G$上的一个最大权匹配。

最大权完美匹配：对于一张带权$w:E\rightarrow\R$的图$G=(V,E)$上的一个完美匹配$M$，若对于$G$上的任意一个完美匹配$M'$都有$w(M) \geq w(M')$，则$M$是$G$上的一个最大权完美匹配。

********

二分图上的匹配问题显然可以归约到网络流问题上，但存在针对这些专门设计的算法（往往是前者的特例），实现难度与常数均较小。

一般图上的匹配问题则较难归约到网络流问题上，且难度较二分图上的匹配问题显著增大。

**常见的匹配算法一般使用增广路寻找最大（权）匹配。**

********

定义：

交错路：对于一张图$G=(V,E)$与其上的一个匹配$M$，$G$上的一条简单路径$P=\{u_1, u_2,...,u_k\}$被成为交错路当且仅当$P$中任意两条相邻边$e_1, e_2$均满足其中一条是匹配边而另一条不是。

增广路：对于一张图$G=(V,E)$与其上的一个匹配$M$，**$G$上的一条交错路$P=\{u_1, u_2,...,u_k\}$是增广路当且仅当其起点$u_1$与终点$u_k$均不在匹配中。**$P$这样的路径被称为增广路是因为在$M$的基础上，若**将增广路$P$中的匹配边移除并将非匹配边加入，可以得到一个新的匹配$M'$且$|M'|=|M|+1$**。（证：因为其起点与终点都不在匹配中，且反转匹配状态后链上每个点仍然仅在一条匹配边中，所以更改匹配状态后不存在两条共顶点的匹配边。）

********

定理（增广路）：
**对于一张图$G=(V,E)$与其上的一个匹配$M$，$M$是$G$的最大匹配当且仅当$G$中不存在增广路。**

证明：

充分性：已知$G$中不存在增广路，接下来需要证明$M$是最大匹配。设$G$的一个最大匹配为$M'$，考虑边集$E'=M \bigoplus M'$（$\bigoplus$为对称差）。

性质1：$E'$中的任意一个顶点度数不超过2。因为任意一个顶点只能被至多两条边作为端点，一条属于$M$而一条属于$M'$。那么$E'$中的任意一个联通分量只能是链或者环。

性质2：$E'$中的任意一个连通分量都不是长度为奇数的链。
若是则其必定是$M'$或$M$的增广路，则要么$M'$不是最大匹配，要么对于$M$存在增广路，产生矛盾。所以$E'$中的任意一条链连通分量都包含相等数量的$M$与$M'$中的边。

性质3：$E'$中的任意一个连通分量都不是长度为奇数的环。
若是则环上必定有两条相邻边属于同一个匹配，产生矛盾。所以$E'$中的任意一个环连通分量都包含相等数量的$M$与$M'$中的边。

所以$E'$中包含相等数量的$M$与$M'$中的边，所以$|M|=|M'|$，$M$是一个最大匹配。

必要性：已知$M$是最大匹配。若$G$中存在增广路则可将其匹配状态翻转使$M$增大，导出矛盾。所以$G$中不存在增广路。

绝大部分匹配算法的核心思路都是寻找增广路。

## 二分图最大匹配

定义：给定一个二分图$G=(X \cup Y,E)$，求$G$中的一个最大匹配。

### 匈牙利算法(最大匹配)

原理：即增广路定理。

过程：依次从每个点出发用dfs寻找增广路。

正确性证明：

需要证明算法结束时图中不存在增广路，即若遍历到某个X中顶点$u$出发未能找到增广路，则此后一直不存在从$u$出发的增广路。

********

引理1：在算法运行中，若从点$u$出发无法找到增广路，之后任意阶段$u$通过交错路能到达的任意Y节点的匹配节点与之前相同。

引理1证明：

若从X节点$u$出发无法找到增广路，则从$u$出发寻找增广路时，$u$通过交错路能够到达的所有Y节点均已被匹配。不妨设找到了从X节点$u'$到Y节点$v'$的增广路$P'$并将其反转后$u$通过交错路$P$到达的Y节点$v$的匹配点从X节点$w_1$变成了X节点$w_2$。即：

$$P=u \dashrightarrow \cdots \dashrightarrow v$$

$$P'=u' \dashrightarrow \cdots \rightarrow w_1 \dashrightarrow v \rightarrow w_2 \dashrightarrow \cdots  \dashrightarrow v'$$

于是
$$u \dashrightarrow \cdots \dashrightarrow v \rightarrow w_2 \dashrightarrow \cdots  \dashrightarrow v'$$
是一条增广路，与假设矛盾。

推论1：在算法运行中，若从点$u$出发无法找到增广路，之后任意阶段$u$通过交错路能到达的Y节点与之前相同。

$u$通过交错路能到达的Y节点的匹配节点不会发生改变，所以从$u$出发的交错路不会发生改变。

********

因为在算法运行过程中，已匹配点不会变为未匹配点，所以若从$u$出发无法找到增广路，则之后永远不存在从$u$出发的增广路，因为$u$通过交错路能够到达的Y节点不会发生改变。

因此若从点$u$出发无法找到增广路，则之后因为从$u$出发能够达到的Y节点不会发生改变，所以之后也不可能找到增广路。进而算法结束后不存在从任意一个未匹配点出发的增广路，算法找到的匹配是最大匹配。

********

实现：

```cpp
const int N = 100001;
typedef pair<int, int> pii;

namespace matching {

vector<int> g[N];   //  g[u]:X中顶点$u$的邻接表
bool vis[N];        //  vis[u]:当前dfs中Y中顶点u是否已被访问过
int lnk[N];         //  lnk[u]:Y中顶点u对应的匹配点。若u未被匹配则lnk[u]=0

//  从X顶点u出发寻找增广路
bool dfs(int u) {
    for (int v : g[u]) {
        //  v已被访问过，且无法从v出发找到增广路或增广路的上一个节点是v则跳过
        if (vis[v] || lnk[v] == u) continue;
        //  v未被访问过，标记v
        vis[v] = 1;
        //  v已有匹配点，且无法从v出发找到增广路则跳过
        if (lnk[v] && !dfs(lnk[v])) continue;
        //  v没有匹配点或找到从lnk[v]出发的增广路，则设v的匹配点为u
        lnk[v] = u; return true;
    }
    //  找不到增广路
    return false;
}

//  接口:
//  int nl: X节点数; X中节点编号为[1...nl]
//  int nr: Y节点数; Y中节点编号为[1...nr]
//  const vector<pii>& es: 二分图中的边集。pii的first为X中节点编号，second为Y中节点编号
//  返回值vector<pii> res: 得到的最大匹配。
vector<pii> match(int nl, int nr, const vector<pii>& es) {
    //  初始化，建图
    for (int i = 1; i <= nl; ++i)
        g[i].clear();
    fill_n(lnk + 1, nr, 0);
    for (pii e : es)
        g[e.first].push_back(e.second);
    //  依次从每个点出发寻找增广路
    for (int i = 1; i <= nl; ++i) {
        fill_n(vis + 1, nr, false);
        dfs(i);
    }
    //  按Y中每个点i的匹配点lnk[i]得到结果
    vector<pii> res;
    for (int i = 1; i <= nr; ++i)
        if (lnk[i]) res.emplace_back(lnk[i], i);
    return res;
}

}
```

********

复杂度：

定理：匈牙利算法的时间复杂度为$O(VE)$，空间复杂度为$O(V+E)$。

共进行$V$轮时间复杂度为$O(E)$的DFS寻找增广路，因此时间复杂度为$O(VE)$。

